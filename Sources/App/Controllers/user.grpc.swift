//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: user.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import SwiftProtobuf


/// The todos service definition.
///
/// Usage: instantiate `Users_UserServiceClient`, then call methods of this protocol to make API calls.
internal protocol Users_UserServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Users_UserServiceClientInterceptorFactoryProtocol? { get }

  func fetchUsers(
    _ request: Users_Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<Users_Empty, Users_UserList>

  func fetchUserById(
    _ request: Users_UserID,
    callOptions: CallOptions?
  ) -> UnaryCall<Users_UserID, Users_User>

  func fetchUserByPhoneNumber(
    _ request: Users_PhoneNumber,
    callOptions: CallOptions?
  ) -> UnaryCall<Users_PhoneNumber, Users_User>

  func checkIfPasswordIsTheSame(
    _ request: Users_PasswordHash,
    callOptions: CallOptions?
  ) -> UnaryCall<Users_PasswordHash, Users_UserPasswordResult>
}

extension Users_UserServiceClientProtocol {
  internal var serviceName: String {
    return "users.UserService"
  }

  /// Return a list of users.
  ///
  /// - Parameters:
  ///   - request: Request to send to FetchUsers.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func fetchUsers(
    _ request: Users_Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Users_Empty, Users_UserList> {
    return self.makeUnaryCall(
      path: "/users.UserService/FetchUsers",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFetchUsersInterceptors() ?? []
    )
  }

  /// Return specific user by id
  ///
  /// - Parameters:
  ///   - request: Request to send to FetchUserById.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func fetchUserById(
    _ request: Users_UserID,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Users_UserID, Users_User> {
    return self.makeUnaryCall(
      path: "/users.UserService/FetchUserById",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFetchUserByIdInterceptors() ?? []
    )
  }

  /// Return specific user by phone number
  ///
  /// - Parameters:
  ///   - request: Request to send to FetchUserByPhoneNumber.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func fetchUserByPhoneNumber(
    _ request: Users_PhoneNumber,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Users_PhoneNumber, Users_User> {
    return self.makeUnaryCall(
      path: "/users.UserService/FetchUserByPhoneNumber",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFetchUserByPhoneNumberInterceptors() ?? []
    )
  }

  /// Return true or false if password matches
  ///
  /// - Parameters:
  ///   - request: Request to send to CheckIfPasswordIsTheSame.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func checkIfPasswordIsTheSame(
    _ request: Users_PasswordHash,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Users_PasswordHash, Users_UserPasswordResult> {
    return self.makeUnaryCall(
      path: "/users.UserService/CheckIfPasswordIsTheSame",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCheckIfPasswordIsTheSameInterceptors() ?? []
    )
  }
}

internal protocol Users_UserServiceClientInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when invoking 'fetchUsers'.
  func makeFetchUsersInterceptors() -> [ClientInterceptor<Users_Empty, Users_UserList>]

  /// - Returns: Interceptors to use when invoking 'fetchUserById'.
  func makeFetchUserByIdInterceptors() -> [ClientInterceptor<Users_UserID, Users_User>]

  /// - Returns: Interceptors to use when invoking 'fetchUserByPhoneNumber'.
  func makeFetchUserByPhoneNumberInterceptors() -> [ClientInterceptor<Users_PhoneNumber, Users_User>]

  /// - Returns: Interceptors to use when invoking 'checkIfPasswordIsTheSame'.
  func makeCheckIfPasswordIsTheSameInterceptors() -> [ClientInterceptor<Users_PasswordHash, Users_UserPasswordResult>]
}

internal final class Users_UserServiceClient: Users_UserServiceClientProtocol {
  internal let channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Users_UserServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the users.UserService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Users_UserServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// The todos service definition.
///
/// To build a server, implement a class that conforms to this protocol.
internal protocol Users_UserServiceProvider: CallHandlerProvider {
  var interceptors: Users_UserServiceServerInterceptorFactoryProtocol? { get }

  /// Return a list of users.
  func fetchUsers(request: Users_Empty, context: StatusOnlyCallContext) -> EventLoopFuture<Users_UserList>

  /// Return specific user by id
  func fetchUserById(request: Users_UserID, context: StatusOnlyCallContext) -> EventLoopFuture<Users_User>

  /// Return specific user by phone number
  func fetchUserByPhoneNumber(request: Users_PhoneNumber, context: StatusOnlyCallContext) -> EventLoopFuture<Users_User>

  /// Return true or false if password matches
  func checkIfPasswordIsTheSame(request: Users_PasswordHash, context: StatusOnlyCallContext) -> EventLoopFuture<Users_UserPasswordResult>
}

extension Users_UserServiceProvider {
  internal var serviceName: Substring { return "users.UserService" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "FetchUsers":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Users_Empty>(),
        responseSerializer: ProtobufSerializer<Users_UserList>(),
        interceptors: self.interceptors?.makeFetchUsersInterceptors() ?? [],
        userFunction: self.fetchUsers(request:context:)
      )

    case "FetchUserById":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Users_UserID>(),
        responseSerializer: ProtobufSerializer<Users_User>(),
        interceptors: self.interceptors?.makeFetchUserByIdInterceptors() ?? [],
        userFunction: self.fetchUserById(request:context:)
      )

    case "FetchUserByPhoneNumber":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Users_PhoneNumber>(),
        responseSerializer: ProtobufSerializer<Users_User>(),
        interceptors: self.interceptors?.makeFetchUserByPhoneNumberInterceptors() ?? [],
        userFunction: self.fetchUserByPhoneNumber(request:context:)
      )

    case "CheckIfPasswordIsTheSame":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Users_PasswordHash>(),
        responseSerializer: ProtobufSerializer<Users_UserPasswordResult>(),
        interceptors: self.interceptors?.makeCheckIfPasswordIsTheSameInterceptors() ?? [],
        userFunction: self.checkIfPasswordIsTheSame(request:context:)
      )

    default:
      return nil
    }
  }
}

internal protocol Users_UserServiceServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'fetchUsers'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeFetchUsersInterceptors() -> [ServerInterceptor<Users_Empty, Users_UserList>]

  /// - Returns: Interceptors to use when handling 'fetchUserById'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeFetchUserByIdInterceptors() -> [ServerInterceptor<Users_UserID, Users_User>]

  /// - Returns: Interceptors to use when handling 'fetchUserByPhoneNumber'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeFetchUserByPhoneNumberInterceptors() -> [ServerInterceptor<Users_PhoneNumber, Users_User>]

  /// - Returns: Interceptors to use when handling 'checkIfPasswordIsTheSame'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeCheckIfPasswordIsTheSameInterceptors() -> [ServerInterceptor<Users_PasswordHash, Users_UserPasswordResult>]
}
